#!/bin/bash

# Skrypt do konwersji projektu vector-wave na strukturę multirepo z customowymi nazwami i opisami

echo "🚀 Konwersja vector-wave na strukturę multirepo z GitHub CLI..."

# Kolory dla lepszej czytelności
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

# Sprawdzenie czy gh jest zainstalowane
if ! command -v gh &> /dev/null; then
    echo -e "${RED}❌ GitHub CLI (gh) nie jest zainstalowane!${NC}"
    echo "Zainstaluj przez: brew install gh"
    echo "Lub pobierz z: https://cli.github.com/"
    exit 1
fi

# Sprawdzenie czy użytkownik jest zalogowany
if ! gh auth status &> /dev/null; then
    echo -e "${YELLOW}⚠️  Musisz się zalogować do GitHub CLI${NC}"
    echo "Wykonaj: gh auth login"
    exit 1
fi

# Pobranie nazwy użytkownika GitHub
GITHUB_USER=$(gh api user --jq .login)
echo -e "${GREEN}✅ Zalogowany jako: $GITHUB_USER${NC}"

# =====================================================
# KONFIGURACJA PROJEKTÓW - EDYTUJ TUTAJ
# =====================================================

# Główne repozytorium
MAIN_REPO_NAME="vectorwave.io"
MAIN_REPO_DESC="AI-powered content platform"
MAIN_REPO_VISIBILITY="public"

# Konfiguracja subprojektów
# Format: ["folder_name"]="repo_name|visibility|description"
declare -A PROJECTS=(
    ["content"]="vector-wave-content|public|Generated content materials, articles, and social media posts"
    ["ideas"]="vector-wave-ideas|public|Ideas bank and creative concepts for content generation"
    ["kolegium"]="vector-wave-editorial-crew|public|AI agents working as editorial crew - the brain of content generation"
    ["n8n"]="vector-wave-n8n-workflows|private|N8N automation workflows for content pipeline"
    ["presenton"]="vector-wave-presenton|private|AI-powered presentation generator with custom templates"
)

# =====================================================
# KONIEC KONFIGURACJI
# =====================================================

# Funkcja do tworzenia pre-commit hook
create_pre_commit_hook() {
    mkdir -p .git/hooks
    cat > .git/hooks/pre-commit << 'HOOK_EOF'
#!/bin/bash

# Pre-commit hook to prevent committing .env and CLAUDE.md files

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m'

# Check for .env files in staged changes
ENV_FILES=$(git diff --cached --name-only | grep -E '(^|/)\.env(\.|$)|\.env$')

if [ ! -z "$ENV_FILES" ]; then
    echo -e "${RED}❌ BŁĄD: Próbujesz commitować pliki .env!${NC}"
    echo -e "${RED}Znalezione pliki:${NC}"
    echo "$ENV_FILES" | while read -r file; do
        echo -e "${YELLOW}  - $file${NC}"
    done
    echo ""
    echo -e "${YELLOW}💡 Wskazówka: Usuń te pliki ze stage area używając:${NC}"
    echo "$ENV_FILES" | while read -r file; do
        echo "   git reset HEAD $file"
    done
    echo ""
    echo -e "${RED}Commit został anulowany ze względów bezpieczeństwa.${NC}"
    exit 1
fi

# Check for CLAUDE.md files in staged changes
CLAUDE_FILES=$(git diff --cached --name-only | grep -iE '(^|/)claude\.md$')

if [ ! -z "$CLAUDE_FILES" ]; then
    echo -e "${RED}❌ BŁĄD: Próbujesz commitować pliki CLAUDE.md!${NC}"
    echo -e "${RED}Te pliki zawierają prywatne instrukcje projektu i nie powinny być publiczne.${NC}"
    echo -e "${RED}Znalezione pliki:${NC}"
    echo "$CLAUDE_FILES" | while read -r file; do
        echo -e "${YELLOW}  - $file${NC}"
    done
    echo ""
    echo -e "${YELLOW}💡 Wskazówka: Usuń te pliki ze stage area używając:${NC}"
    echo "$CLAUDE_FILES" | while read -r file; do
        echo "   git reset HEAD $file"
    done
    echo ""
    echo -e "${RED}Commit został anulowany ze względów bezpieczeństwa.${NC}"
    exit 1
fi

exit 0
HOOK_EOF
    
    chmod +x .git/hooks/pre-commit
}

# Funkcja do tworzenia kompleksowego .gitignore
create_comprehensive_gitignore() {
    cat > .gitignore << 'GITIGNORE_EOF'
# CRITICAL: Environment variables - NEVER commit these!
.env
.env.*
*.env
.env.local
.env.development
.env.test
.env.production
.env.staging

# Recursively ignore ALL .env files in any subdirectory
**/.env
**/.env.*
**/*.env

# API keys and secrets
**/secrets/
**/credentials/
*.key
*.pem
*.cert
*.crt
api_key.txt
secrets.json
credentials.json
config.secret.*

# Database
*.db
*.sqlite
*.sqlite3

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov
.nyc_output

# Dependency directories
node_modules/
jspm_packages/
.pnp
.pnp.js

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
PIPFILE.lock
venv/
ENV/
env/
.venv/

# TypeScript
*.tsbuildinfo
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Temporary files
*.tmp
*.temp
*.bak
*.backup
*.old

# Docker
Dockerfile.local
docker-compose.override.yml
docker-compose.local.yml

GITIGNORE_EOF
}

# Funkcja do parsowania konfiguracji
parse_config() {
    local config=$1
    IFS='|' read -r repo_name visibility description <<< "$config"
    echo "$repo_name" "$visibility" "$description"
}

# Funkcja do tworzenia i inicjalizacji repo
create_and_init_repo() {
    local folder=$1
    local config="${PROJECTS[$folder]}"
    read -r repo_name visibility description <<< $(parse_config "$config")
    
    echo -e "${YELLOW}📦 Przetwarzanie: $folder${NC}"
    echo -e "${BLUE}   📝 Nazwa repo: $repo_name${NC}"
    echo -e "${BLUE}   🔒 Widoczność: $visibility${NC}"
    echo -e "${BLUE}   📄 Opis: $description${NC}"
    
    # Sprawdź czy repo już istnieje
    if gh repo view "$GITHUB_USER/$repo_name" &> /dev/null; then
        echo -e "${YELLOW}   ⚠️  Repo $repo_name już istnieje, pomijam tworzenie${NC}"
    else
        # Tworzenie repo na GitHub
        echo -e "${BLUE}   🌐 Tworzenie repo na GitHub...${NC}"
        if [ "$visibility" == "private" ]; then
            gh repo create "$repo_name" --private --description "$description"
        else
            gh repo create "$repo_name" --public --description "$description"
        fi
        echo -e "${GREEN}   ✅ Utworzono repo: $repo_name${NC}"
    fi
    
    # Inicjalizacja lokalnego repo
    if [ -d "$folder" ]; then
        cd "$folder"
        
        # Sprawdź czy to już jest repo git
        if [ -d ".git" ]; then
            echo -e "${YELLOW}   ⚠️  Folder $folder już jest repozytorium git${NC}"
            
            # Upewnij się że istnieje .gitignore nawet w istniejącym repo
            if [ ! -f ".gitignore" ]; then
                echo -e "${BLUE}   📝 Tworzenie .gitignore dla istniejącego repo...${NC}"
                create_comprehensive_gitignore
                echo "" >> .gitignore
                echo "# Project-specific context files" >> .gitignore
                echo "CLAUDE.md" >> .gitignore
                echo "claude.md" >> .gitignore
                git add .gitignore
                git commit -m "Add comprehensive .gitignore with env protection"
            fi
            
            # Instaluj pre-commit hook nawet w istniejącym repo
            create_pre_commit_hook
            echo -e "${GREEN}   ✅ Zainstalowano pre-commit hook${NC}"
            
            # Dodaj remote jeśli nie istnieje
            if ! git remote get-url origin &> /dev/null; then
                git remote add origin "git@github.com:$GITHUB_USER/$repo_name.git"
                echo -e "${GREEN}   ✅ Dodano remote origin${NC}"
            fi
        else
            # Nowe repo
            git init
            
            # Tworzenie kompleksowego .gitignore dla subprojektu
            create_comprehensive_gitignore
            
            # Dodaj CLAUDE.md do .gitignore subprojektu
            echo "" >> .gitignore
            echo "# Project-specific context files" >> .gitignore
            echo "CLAUDE.md" >> .gitignore
            echo "claude.md" >> .gitignore
            
            # Instaluj pre-commit hook
            create_pre_commit_hook
            
            # Tworzenie README dla subprojektu
            if [ ! -f "README.md" ]; then
                cat > README.md << EOF
# $repo_name

$description

Part of [Vector Wave](https://github.com/$GITHUB_USER/$MAIN_REPO_NAME) platform.

## Overview

This repository contains the $folder module of the Vector Wave AI content generation platform.

## Setup

See the main [Vector Wave](https://github.com/$GITHUB_USER/$MAIN_REPO_NAME) repository for setup instructions.
EOF
            fi
            
            git add .
            git commit -m "Initial commit: $folder module for Vector Wave platform"
            git branch -M main
            git remote add origin "git@github.com:$GITHUB_USER/$repo_name.git"
            echo -e "${GREEN}   ✅ Zainicjalizowano lokalne repo${NC}"
        fi
        
        # Push do GitHub
        echo -e "${BLUE}   📤 Push do GitHub...${NC}"
        if git push -u origin main; then
            echo -e "${GREEN}   ✅ Push zakończony sukcesem${NC}"
        else
            echo -e "${YELLOW}   ⚠️  Push nieudany - sprawdź ręcznie${NC}"
        fi
        
        cd ..
    else
        echo -e "${RED}   ❌ Folder $folder nie istnieje!${NC}"
    fi
    
    echo ""
}

# Tworzenie głównego repozytorium vector-wave
echo -e "${YELLOW}📦 Inicjalizacja głównego repozytorium...${NC}"

# Tworzenie kompleksowego .gitignore dla głównego repo
create_comprehensive_gitignore

# Dodaj PROJECT-CONTEXT.md i CLAUDE.md do .gitignore
echo "" >> .gitignore
echo "# Project-specific context files (not for public repos)" >> .gitignore
echo "PROJECT-CONTEXT.md" >> .gitignore
echo "CLAUDE.md" >> .gitignore
echo "claude.md" >> .gitignore

# Instaluj pre-commit hook w głównym repo
create_pre_commit_hook
echo -e "${GREEN}✅ Zainstalowano pre-commit hook w głównym repo${NC}"

# Inicjalizacja głównego repo
if [ ! -d ".git" ]; then
    git init
    git add README.md *.md .gitignore
    git commit -m "Initial commit: Vector Wave AI content generation platform"
fi

# Tworzenie głównego repo na GitHub
if ! gh repo view "$GITHUB_USER/$MAIN_REPO_NAME" &> /dev/null; then
    echo -e "${BLUE}🌐 Tworzenie głównego repo na GitHub...${NC}"
    if [ "$MAIN_REPO_VISIBILITY" == "private" ]; then
        gh repo create "$MAIN_REPO_NAME" --private --description "$MAIN_REPO_DESC"
    else
        gh repo create "$MAIN_REPO_NAME" --public --description "$MAIN_REPO_DESC"
    fi
    git remote add origin "git@github.com:$GITHUB_USER/$MAIN_REPO_NAME.git"
    git push -u origin main
    echo -e "${GREEN}✅ Utworzono główne repo: $MAIN_REPO_NAME${NC}"
else
    echo -e "${YELLOW}⚠️  Główne repo już istnieje${NC}"
fi

echo ""
echo -e "${YELLOW}========================================${NC}"
echo -e "${BLUE}🔧 Tworzenie i inicjalizacja submodułów${NC}"
echo -e "${YELLOW}========================================${NC}"
echo ""

# Przetwarzanie każdego projektu
for folder in "${!PROJECTS[@]}"; do
    create_and_init_repo "$folder"
done

# Dodawanie submodułów do głównego repo
echo -e "${YELLOW}🔗 Dodawanie submodułów do głównego repo...${NC}"
for folder in "${!PROJECTS[@]}"; do
    config="${PROJECTS[$folder]}"
    read -r repo_name visibility description <<< $(parse_config "$config")
    
    if [ ! -d "$folder/.git" ]; then
        echo -e "${RED}❌ Pominięto $folder - nie jest repozytorium git${NC}"
        continue
    fi
    
    # Usuń folder z głównego repo jeśli istnieje
    if [ -d "$folder" ] && [ ! -f ".gitmodules" ]; then
        git rm -r --cached "$folder" 2>/dev/null || true
        git commit -m "Remove $folder folder before adding as submodule" 2>/dev/null || true
    fi
    
    # Dodaj jako submodule
    if ! grep -q "path = $folder" .gitmodules 2>/dev/null; then
        git submodule add "git@github.com:$GITHUB_USER/$repo_name.git" "$folder"
        echo -e "${GREEN}✅ Dodano submodule: $folder${NC}"
    else
        echo -e "${YELLOW}⚠️  Submodule $folder już istnieje${NC}"
    fi
done

# Commit submodułów
git add .gitmodules
git commit -m "Add all submodules" 2>/dev/null || true
git push

# Tworzenie README jeśli nie istnieje
if [ ! -f "README.md" ]; then
    cat > README.md << EOF
# Vector Wave - AI Content Generation Platform

$MAIN_REPO_DESC

## 🚀 Overview

Vector Wave is an advanced content generation platform that uses AI agents to automatically create, optimize, and publish content across multiple channels.

## 📦 Project Structure

| Module | Repository | Description | Status |
|--------|------------|-------------|--------|
EOF

    # Dodaj informacje o każdym module
    for folder in content ideas kolegium n8n presenton; do
        if [ -n "${PROJECTS[$folder]}" ]; then
            config="${PROJECTS[$folder]}"
            read -r repo_name visibility description <<< $(parse_config "$config")
            
            # Status badge
            status="🟢 Active"
            [ "$folder" == "ideas" ] || [ "$folder" == "kolegium" ] && status="🟡 In Development"
            
            # Visibility icon
            vis_icon="🔓"
            [ "$visibility" == "private" ] && vis_icon="🔒"
            
            echo "| $folder | [$repo_name](https://github.com/$GITHUB_USER/$repo_name) $vis_icon | $description | $status |" >> README.md
        fi
    done

    cat >> README.md << EOF

## 🛠️ Setup

### Clone with all submodules
\`\`\`bash
git clone --recurse-submodules git@github.com:$GITHUB_USER/$MAIN_REPO_NAME.git
cd $MAIN_REPO_NAME
\`\`\`

### Update submodules
\`\`\`bash
git submodule update --init --recursive
\`\`\`

### Work with specific module
\`\`\`bash
cd module-name
git checkout main
git pull origin main
# make changes...
git add .
git commit -m "Your changes"
git push origin main
\`\`\`

### Update submodule reference in main repo
\`\`\`bash
cd ..
git add module-name
git commit -m "Update module-name to latest version"
git push
\`\`\`

## 🤖 Features

- **AI Agents** - Autonomous agents for content research and generation
- **Content Pipeline** - Automated workflow from idea to publication
- **Multi-Channel Publishing** - Support for various social media platforms
- **Visual Generation** - Integration with design tools
- **Analytics** - Performance tracking and optimization

## 📚 Documentation

- [Tech Blog Style Guide](./tech-blog-styleguide.md)
- [5 Tech Blog Influencers Analysis](./5-tech-blog-influencers-analysis.md)

## 🔐 License

See individual repositories for license information.
EOF
    
    git add README.md
    git commit -m "Add comprehensive README"
    git push
fi

# Podsumowanie
echo ""
echo -e "${YELLOW}========================================${NC}"
echo -e "${GREEN}✅ Konwersja zakończona!${NC}"
echo -e "${YELLOW}========================================${NC}"
echo ""
echo -e "${BLUE}📋 Utworzone repozytoria:${NC}"
echo -e "   🏠 Główne: https://github.com/$GITHUB_USER/$MAIN_REPO_NAME"
for folder in "${!PROJECTS[@]}"; do
    config="${PROJECTS[$folder]}"
    read -r repo_name visibility description <<< $(parse_config "$config")
    vis_icon="🔓"
    [ "$visibility" == "private" ] && vis_icon="🔒"
    echo -e "   📦 $vis_icon $folder: https://github.com/$GITHUB_USER/$repo_name"
done
echo ""
echo -e "${YELLOW}💡 Następne kroki:${NC}"
echo "1. Sprawdź repozytoria na GitHub"
echo "2. Sklonuj główne repo ze wszystkimi submodułami:"
echo "   git clone --recurse-submodules git@github.com:$GITHUB_USER/$MAIN_REPO_NAME.git"
echo ""